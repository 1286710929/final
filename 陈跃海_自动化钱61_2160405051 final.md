



#                                               数字图像处理第七次作业

 

 

 

​                                                                                             摘要

​    本次作业主要针对数字图像处理中边缘检测和直线提取。本次作业主要是基于opencv库下的一些处理方法，编程语言采用c++。

 

 

 

​                                                                                                                                                      自动化钱61 

​                                                                                                                                                      陈跃海

​                                                                                                                                                      2160405051

 

 

 

## 1、1. 首先对测试图像（文件名为：test1~test6）进行边缘检测，可采用书上介绍的Sobel等模板或者cann算子方法；比较不同边缘检测算法（2种以上）

 

### 1.1 解题思路

​        边缘检测的一般步骤：

 

1. 滤波——消除噪声
2. 增强——使边界轮廓更加明显
3. 检测——选出边缘点

### 1.2 关键代码

canny算子

```c++
#include<opencv2/opencv.hpp>
#include<opencv2\core\core.hpp>
#include<opencv2/highgui/highgui.hpp>
#include<opencv2\imgproc\imgproc.hpp>
#include<iostream>

using namespace std;
using namespace cv;
//全局变量声明


int main()
{
	Mat img = imread("C:\\Users\\chenyuehai\\Documents\\Tencent Files\\1286710929\\FileRecv\\作业-直线检测\\test6.jpg");
	imshow("原始图", img);
	Mat DstPic, edge, grayImage;

	//创建与src同类型和同大小的矩阵
	DstPic.create(img.size(), img.type());

	//将原始图转化为灰度图
	cvtColor(img, grayImage, COLOR_BGR2GRAY);

	//先使用3*3内核来降噪
	blur(grayImage, edge, Size(3, 3));

	//运行canny算子
	Canny(edge, edge, 3, 9, 3);

	imshow("边缘提取效果", edge);
	waitKey(0);
}
```

```c++
#include<opencv2\opencv.hpp>   
#include<opencv2\highgui\highgui.hpp>

using namespace std;
using namespace cv;

//边缘检测
int main()
{
	Mat img = imread("C:\\Users\\chenyuehai\\Documents\\Tencent Files\\1286710929\\FileRecv\\作业-直线检测\\test6.jpg");

	imshow("原始图", img);

	Mat grad_x, grad_y;
	Mat abs_grad_x, abs_grad_y, dst;

	//求x方向梯度
	Sobel(img, grad_x, CV_16S, 1, 0, 3, 1, 1, BORDER_DEFAULT);
	convertScaleAbs(grad_x, abs_grad_x);
	imshow("x方向soble", abs_grad_x);

	//求y方向梯度
	Sobel(img, grad_y, CV_16S, 0, 1, 3, 1, 1, BORDER_DEFAULT);
	convertScaleAbs(grad_y, abs_grad_y);
	imshow("y向soble", abs_grad_y);

	//合并梯度
	addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst);
	imshow("整体方向soble", dst);


	waitKey(0);

}
```

soble算子

### 1.3 实验结果

canny算子：

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/canny1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/canny2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/canny3.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/canny4.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/canny5.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/canny6.png]()

soble算子：

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/soble1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/soble2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/soble3.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/soble4.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/soble5.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/soble6.png]()

### 1.4 实验分析

1.看了canny算法提取的轮廓图，居然把那么细致的额轮廓都提取出来了！

2.sobel的轮廓提取明显有没cnany的那么细致，只是把一些明显轮廓的边缘提取出来了，看起来会更舒服一点



## 2、直线检测

 

### 2.1 解题思路

​       提取出边缘之后，利用Hough直线检测进行检测。

### 2.2 关键代码

```c++
 //---------------------------------【头文件、命名空间包含部分】----------------------------
// 描述：包含程序所使用的头文件和命名空间
//------------------------------------------------------------------------------------------------
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
using namespace cv;
using namespace std;




//-----------------------------------【main( )函数】--------------------------------------------
// 描述：控制台应用程序的入口函数，我们的程序从这里开始
//-----------------------------------------------------------------------------------------------
int main()
{
	//【1】载入原始图和Mat变量定义   
	Mat srcImage = imread("C:\\Users\\chenyuehai\\Documents\\Tencent Files\\1286710929\\FileRecv\\作业-直线检测\\test6.jpg");  //工程目录下应该有一张名为1.jpg的素材图
	Mat midImage, dstImage;//临时变量和目标图的定义


						   //【2】进行边缘检测和转化为灰度图
	Canny(srcImage, midImage, 3, 9, 3);//进行一此canny边缘检测
	cvtColor(midImage, dstImage, COLOR_GRAY2BGR);//转化边缘检测后的图为灰度图


												 //【3】进行霍夫线变换
	vector<Vec2f> lines;//定义一个矢量结构lines用于存放得到的线段矢量集合
	HoughLines(midImage, lines, 1, CV_PI / 180,500, 0, 0);


	//【4】依次在图中绘制出每条线段
	for (size_t i = 0; i < lines.size(); i++)
	{
		float rho = lines[i][0], theta = lines[i][1];
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a*rho, y0 = b*rho;
		pt1.x = cvRound(x0 + 1000 * (-b));
		pt1.y = cvRound(y0 + 1000 * (a));
		pt2.x = cvRound(x0 - 1000 * (-b));
		pt2.y = cvRound(y0 - 1000 * (a));

		line(dstImage, pt1, pt2, Scalar(55, 100, 195), 1, LINE_AA);
	}


	//【5】显示原始图  
	imshow("【原始图】", srcImage);


	//【6】边缘检测后的图 
	imshow("【边缘检测后的图】", midImage);


	//【7】显示效果图  
	imshow("【效果图】", dstImage);


	waitKey(0);


	return 0;
}
```





### 2.3实验结果

阈值分别为150和400

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF1.1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF1.2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF2.1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF2.2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF3.1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF3.2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF4.1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF4.2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF5.1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF5.2.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF6.1.png]()

![https://github.com/1286710929/hw5/blob/master/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/%E7%9B%B4%E7%BA%BF6.2.png]()







### 2.4实验分析

​        对于canny边缘提取，hough直线的阈值很大程度上影响了直线的数目。

